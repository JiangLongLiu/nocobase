# 依赖管理

<cite>
**本文档引用文件**  
- [plugin-manager.ts](file://packages/core/server/src/plugin-manager/plugin-manager.ts)
- [utils.ts](file://packages/core/server/src/plugin-manager/utils.ts)
- [getPackages.ts](file://packages/core/build/src/utils/getPackages.ts)
- [toposort.ts](file://packages/core/utils/src/toposort.ts)
- [deps.ts](file://packages/core/server/src/plugin-manager/deps.ts)
- [plugin-acl\package.json](file://packages/plugins/@nocobase/plugin-acl/package.json)
- [plugin-auth\package.json](file://packages/plugins/@nocobase/plugin-auth/package.json)
</cite>

## 目录
1. [插件依赖声明](#插件依赖声明)
2. [依赖解析算法](#依赖解析算法)
3. [插件加载顺序](#插件加载顺序)
4. [版本兼容性检查](#版本兼容性检查)
5. [最佳实践](#最佳实践)
6. [性能优化与问题排查](#性能优化与问题排查)

## 插件依赖声明

NocoBase插件通过`package.json`文件中的`peerDependencies`字段声明其依赖关系。这种设计允许插件指定其依赖的其他NocoBase核心包或插件，同时避免版本冲突。插件开发者在开发时需要明确声明其依赖的包及其版本范围。

例如，`@nocobase/plugin-acl`插件在其`package.json`文件中声明了对多个核心包的依赖：

```json
{
  "peerDependencies": {
    "@nocobase/acl": "1.x",
    "@nocobase/actions": "1.x",
    "@nocobase/cache": "1.x",
    "@nocobase/client": "1.x",
    "@nocobase/database": "1.x",
    "@nocobase/server": "1.x",
    "@nocobase/test": "1.x",
    "@nocobase/utils": "1.x"
  }
}
```

同样，`@nocobase/plugin-auth`插件也声明了类似的依赖关系：

```json
{
  "peerDependencies": {
    "@nocobase/actions": "1.x",
    "@nocobase/auth": "1.x",
    "@nocobase/client": "1.x",
    "@nocobase/database": "1.x",
    "@nocobase/server": "1.x",
    "@nocobase/test": "1.x"
  }
}
```

这些`peerDependencies`声明确保了插件在安装时会检查其依赖的包是否满足版本要求，从而保证系统的稳定性和兼容性。

**Section sources**
- [plugin-acl\package.json](file://packages/plugins/@nocobase/plugin-acl/package.json)
- [plugin-auth\package.json](file://packages/plugins/@nocobase/plugin-auth/package.json)

## 依赖解析算法

NocoBase使用拓扑排序算法来解析插件依赖关系，确保插件按照正确的顺序加载。核心依赖解析逻辑位于`plugin-manager.ts`文件中，使用`@hapi/topo`库实现拓扑排序。

依赖解析的主要步骤如下：

1. **收集依赖信息**：从每个插件的`package.json`文件中读取`dependencies`、`devDependencies`和`peerDependencies`字段，获取所有依赖项。
2. **构建依赖图**：将每个插件作为节点，依赖关系作为有向边，构建一个有向无环图（DAG）。
3. **拓扑排序**：使用拓扑排序算法对依赖图进行排序，确保每个插件都在其依赖项之后加载。

在`getPackages.ts`文件中，`sortPackages`函数实现了这一算法：

```typescript
export function sortPackages(packages: Package[]): Package[] {
  const sorter = new Topo.Sorter<Package>();
  for (const pkg of packages) {
    const pkgJson = require(`${pkg.location}/package.json`);
    const after = Object.keys({ 
      ...pkgJson.dependencies, 
      ...pkgJson.devDependencies, 
      ...pkgJson.peerDependencies 
    });
    sorter.add(pkg, { after, group: pkg.name });
  }
  return sorter.nodes;
}
```

该算法通过`after`字段指定每个包应该在哪些其他包之后加载，从而确保依赖关系的正确性。

**Section sources**
- [getPackages.ts](file://packages/core/build/src/utils/getPackages.ts)
- [plugin-manager.ts](file://packages/core/server/src/plugin-manager/plugin-manager.ts)

## 插件加载顺序

插件加载顺序由拓扑排序结果决定，确保每个插件都在其所有依赖项加载完成后再加载。NocoBase的插件管理器在启动时会执行以下步骤：

1. **初始化预设插件**：首先加载通过`addPreset`方法添加的预设插件。
2. **排序插件**：使用拓扑排序算法对所有插件进行排序。
3. **按序加载**：按照排序结果依次加载每个插件。

在`plugin-manager.ts`文件中，`load`方法实现了插件加载逻辑：

```typescript
async load(options: any = {}) {
  this.app.log.debug('loading plugins...');
  this.app.setMaintainingMessage('loading plugins...');
  const total = this.pluginInstances.size;

  let current = 0;

  for (const [P, plugin] of this.getPlugins()) {
    if (plugin.state.loaded) {
      continue;
    }

    const name = plugin.name || P.name;
    current += 1;

    this.app.setMaintainingMessage(`before load plugin [${name}], ${current}/${total}`);
    if (!plugin.enabled) {
      continue;
    }
    this.app.logger.trace(`before load plugin [${name}]`, { submodule: 'plugin-manager', method: 'load', name });
    await plugin.beforeLoad();
  }

  current = 0;

  for (const [P, plugin] of this.getPlugins()) {
    if (plugin.state.loaded) {
      continue;
    }
    const name = plugin.name || P.name;
    current += 1;
    this.app.setMaintainingMessage(`load plugin [${name}], ${current}/${total}`);

    if (!plugin.enabled) {
      continue;
    }

    await this.app.emitAsync('beforeLoadPlugin', plugin, options);
    this.app.logger.trace(`load plugin [${name}] `, { submodule: 'plugin-manager', method: 'load', name });
    await plugin.loadCollections();
    await plugin.load();
    plugin.state.loaded = true;
    await this.app.emitAsync('afterLoadPlugin', plugin, options);
  }
}
```

该方法首先调用`beforeLoad`钩子，然后执行`load`方法加载插件，最后触发`afterLoadPlugin`事件。

**Section sources**
- [plugin-manager.ts](file://packages/core/server/src/plugin-manager/plugin-manager.ts)

## 版本兼容性检查

NocoBase通过`deps.ts`文件定义了核心依赖的版本范围，并在运行时检查插件的兼容性。`deps.ts`文件中定义了NocoBase及其相关库的版本约束：

```typescript
const deps: Record<string, string> = {
  '@nocobase': `${version.split('.').slice(0, 2).join('.')}.x`, // 0.12.x
  '@formily': '2.x',
  '@formily/antd-v5': '1.x',
  jsonwebtoken: '9.x',
  'cache-manager': '5.x',
  sequelize: '6.x',
  umzug: '3.x',
  'async-mutex': '0.5.x',
  '@formulajs/formulajs': '4.x',
  mathjs: '10.x',
  winston: '3.x',
  'winston-daily-rotate-file': '4.x',
  koa: '2.x',
  '@koa/cors': '5.x',
  '@koa/router': '13.x',
  multer: '1.x',
  '@koa/multer': '3.x',
  'koa-bodyparser': '4.x',
  'koa-static': '5.x',
  'koa-send': '5.x',
  react: '18.x',
  'react-dom': '18.x',
  'react-router': '6.x',
  'react-router-dom': '6.x',
  antd: '5.x',
  'antd-style': '3.x',
  '@ant-design/icons': '5.x',
  '@ant-design/cssinjs': '1.x',
  i18next: '22.x',
  'react-i18next': '11.x',
  '@dnd-kit/core': '6.x',
  '@dnd-kit/sortable': '7.x',
  dayjs: '1.x',
  mysql2: '3.x',
  pg: '8.x',
  'pg-hstore': '2.x',
  sqlite3: '5.x',
  supertest: '6.x',
  axios: '1.7.x',
  '@emotion/css': '11.x',
  ahooks: '3.x',
  lodash: '4.x',
  'china-division': '2.x',
  cronstrue: '2.x',
  '@nocobase/license-kit': '0.3.x',
};
```

在`utils.ts`文件中，`checkAndGetCompatible`函数实现了版本兼容性检查：

```typescript
export async function checkAndGetCompatible(packageName: string) {
  const compatible = await getCompatible(packageName);
  if (!compatible) {
    return {
      isCompatible: false,
      depsCompatible: [],
    };
  }
  return {
    isCompatible: compatible.every((item) => item.result),
    depsCompatible: compatible,
  };
}
```

该函数检查插件声明的依赖版本是否满足`deps.ts`中定义的版本范围，确保系统整体的版本兼容性。

**Section sources**
- [deps.ts](file://packages/core/server/src/plugin-manager/deps.ts)
- [utils.ts](file://packages/core/server/src/plugin-manager/utils.ts)

## 最佳实践

为了设计松耦合的插件架构并最小化依赖关系，建议遵循以下最佳实践：

1. **使用peerDependencies**：优先使用`peerDependencies`而不是`dependencies`来声明对NocoBase核心包的依赖，避免版本冲突。
2. **最小化依赖**：只声明必要的依赖项，避免引入不必要的包。
3. **语义化版本控制**：使用语义化版本控制（如`1.x`）来指定版本范围，允许向后兼容的更新。
4. **插件隔离**：尽量使插件功能独立，减少插件间的直接依赖。
5. **接口定义**：通过明确定义的接口进行插件间通信，而不是直接访问内部实现。

这些实践有助于创建可维护、可扩展的插件生态系统。

## 性能优化与问题排查

### 性能优化技巧

1. **缓存依赖解析结果**：将拓扑排序的结果缓存起来，避免重复计算。
2. **并行加载**：对于没有依赖关系的插件，可以并行加载以提高启动速度。
3. **懒加载**：对于非核心功能的插件，可以采用懒加载策略，在需要时才加载。

### 常见依赖问题排查

1. **循环依赖**：检查是否有A依赖B，B又依赖A的情况。可以使用依赖图可视化工具来识别循环依赖。
2. **版本冲突**：当多个插件依赖同一包的不同版本时，会出现版本冲突。应统一版本要求或使用兼容的版本范围。
3. **缺失依赖**：确保所有声明的依赖都已正确安装。可以使用`npm ls`命令检查依赖树。
4. **加载顺序错误**：如果插件在依赖项之前加载，会导致运行时错误。确保拓扑排序正确。

通过遵循这些优化技巧和排查方法，可以有效解决NocoBase插件系统中的依赖管理问题。
# 依赖管理

<cite>
**本文档中引用的文件**  
- [application.ts](file://packages/core/server/src/application.ts)
- [plugin-manager.ts](file://packages/core/server/src/plugin-manager/plugin-manager.ts)
- [plugin-manager-repository.ts](file://packages/core/server/src/plugin-manager/plugin-manager-repository.ts)
- [plugin.ts](file://packages/core/server/src/plugin.ts)
- [package.json](file://packages/core/server/package.json)
</cite>

## 目录
1. [引言](#引言)
2. [插件依赖声明机制](#插件依赖声明机制)
3. [依赖解析与加载顺序控制](#依赖解析与加载顺序控制)
4. [版本兼容性与冲突处理](#版本兼容性与冲突处理)
5. [延迟加载与按需加载策略](#延迟加载与按需加载策略)
6. [最佳实践与常见陷阱](#最佳实践与常见陷阱)

## 引言

NocoBase 是一个基于插件架构的低代码开发平台，其核心功能通过插件系统实现。插件间的依赖管理是确保系统稳定运行的关键机制。本文档深入解析 NocoBase 插件系统的依赖管理机制，涵盖依赖声明、解析、加载顺序控制、版本兼容性处理以及优化策略。

**Section sources**
- [application.ts](file://packages/core/server/src/application.ts#L217-L1423)

## 插件依赖声明机制

在 NocoBase 中，插件之间的依赖关系主要通过 `package.json` 文件中的 `peerDependencies` 字段进行声明。这种设计允许插件明确指出其运行所依赖的其他插件，确保在加载时相关插件已正确初始化。

例如，在 `@nocobase/server` 的 `package.json` 中，可以看到它依赖于多个核心插件：

```json
"dependencies": {
  "@nocobase/acl": "1.9.32",
  "@nocobase/actions": "1.9.32",
  "@nocobase/auth": "1.9.32"
}
```

此外，插件类中也可以通过 `requiredPlugins()` 方法声明运行时依赖，该方法返回一个插件名称数组，系统会在启用当前插件前检查这些依赖插件是否已启用。

**Section sources**
- [package.json](file://packages/core/server/package.json#L7-L55)
- [plugin.ts](file://packages/core/server/src/plugin.ts#L205-L207)

## 依赖解析与加载顺序控制

NocoBase 使用拓扑排序（Topological Sorting）算法来确定插件的加载顺序，确保依赖插件总是在被依赖插件之前加载。系统基于插件间的依赖关系构建有向无环图（DAG），并通过 `@hapi/topo` 库实现排序。

关键实现位于 `PluginManagerRepository` 类的 `sort()` 方法中：

```typescript
async sort(names: string[]) {
  const pluginNames = _.castArray(names);
  if (pluginNames.length === 1) {
    return pluginNames;
  }
  const sorter = new Topo.Sorter<string>();
  for (const pluginName of pluginNames) {
    let packageJson: any = {};
    try {
      packageJson = await PluginManager.getPackageJson(pluginName);
    } catch (error) {
      packageJson = {};
    }
    const peerDependencies = Object.keys(packageJson?.peerDependencies || {});
    sorter.add(pluginName, { after: peerDependencies, group: packageJson?.packageName || pluginName });
  }
  return sorter.nodes;
}
```

该方法遍历所有待加载插件，读取其 `package.json` 中的 `peerDependencies`，并将依赖关系添加到排序器中。最终返回的 `sorter.nodes` 即为正确的加载顺序。

**Section sources**
- [plugin-manager-repository.ts](file://packages/core/server/src/plugin-manager/plugin-manager-repository.ts#L124-L141)
- [plugin-manager.ts](file://packages/core/server/src/plugin-manager/plugin-manager.ts#L1151-L1163)

## 版本兼容性与冲突处理

NocoBase 通过 `checkAndGetCompatible` 工具函数检查插件的版本兼容性。该函数会读取插件的 `package.json` 并验证其依赖的版本范围是否满足当前环境的要求。

在插件管理界面中，系统会展示依赖兼容性检查结果，包括：
- 依赖插件名称
- 所需版本范围
- 当前安装版本
- 兼容性检查结果（通过/失败）

当检测到版本冲突时，系统会阻止不兼容的插件启用，并提示用户进行版本升级或降级。此外，`PluginManager` 在启用插件时会调用 `beforeEnable()` 钩子，允许插件自身进行更复杂的兼容性检查。

**Section sources**
- [plugin.ts](file://packages/core/server/src/plugin.ts#L242)
- [plugin-manager-repository.ts](file://packages/core/server/src/plugin-manager/plugin-manager-repository.ts#L58-L65)

## 延迟加载与按需加载策略

为优化系统启动性能，NocoBase 实现了延迟加载和按需加载策略。插件默认在系统初始化时按依赖顺序批量加载，但某些非核心插件可以配置为按需加载。

`PluginManager` 提供了 `load()` 方法用于动态加载插件，支持以下场景：
- 用户访问特定功能时动态加载相关插件
- 系统资源充足时预加载可能用到的插件
- 根据用户权限按需加载功能模块

此外，系统通过 `enablePerfHooks` 配置项监控插件加载性能，帮助开发者识别加载瓶颈。

**Section sources**
- [plugin-manager.ts](file://packages/core/server/src/plugin-manager/plugin-manager.ts#L1129-L1135)
- [application.ts](file://packages/core/server/src/application.ts#L672-L742)

## 最佳实践与常见陷阱

### 最佳实践
1. **明确声明依赖**：在 `package.json` 中准确声明 `peerDependencies`
2. **使用语义化版本**：遵循 SemVer 规范，避免破坏性变更
3. **合理划分插件**：保持插件职责单一，减少循环依赖
4. **实现兼容性检查**：在 `beforeEnable()` 中添加版本验证逻辑

### 常见陷阱
1. **循环依赖**：避免插件 A 依赖 B，同时 B 依赖 A
2. **版本冲突**：多个插件依赖同一插件的不同版本
3. **过度依赖**：不必要的依赖会增加系统复杂性和启动时间
4. **忽略加载顺序**：假设插件加载顺序固定而不进行显式声明

通过遵循这些最佳实践，可以构建稳定、可维护的插件生态系统。

**Section sources**
- [plugin.ts](file://packages/core/server/src/plugin.ts#L124-L130)
- [application.ts](file://packages/core/server/src/application.ts#L700-L702)
# 版本控制

<cite>
**本文档引用文件**  
- [database.ts](file://packages/core/database/src/database.ts)
- [migration.ts](file://packages/core/database/src/migration.ts)
- [migration.ts](file://packages/core/server/src/migration.ts)
- [create-migration.ts](file://packages/core/server/src/commands/create-migration.ts)
- [application.ts](file://packages/core/server/src/application.ts)
</cite>

## 目录
1. [迁移版本号生成与排序机制](#迁移版本号生成与排序机制)
2. [迁移历史记录存储与查询接口](#迁移历史记录存储与查询接口)
3. [迁移版本冲突处理策略](#迁移版本冲突处理策略)
4. [迁移脚本兼容性管理](#迁移脚本兼容性管理)
5. [可维护的迁移版本体系设计示例](#可维护的迁移版本体系设计示例)

## 迁移版本号生成与排序机制

NocoBase使用基于时间戳和语义化版本的双重机制来确保迁移脚本的有序执行。迁移文件名以时间戳开头（YYYYMMDDHHmmss格式），确保全局唯一性和自然排序。同时，通过`appVersion`字段定义迁移适用的应用版本范围，实现版本条件控制。

迁移脚本的执行顺序由Umzug迁移工具管理，通过`Migrations.callback()`方法返回的排序逻辑确定执行顺序。该方法使用`lodash.sortBy`对迁移项进行排序，排序依据为迁移名称的最后一部分（即时间戳），确保按时间顺序执行。

迁移脚本的版本号生成规则在`create-migration.ts`命令中定义，根据当前应用版本自动生成下一个版本号。对于预发布版本（包含alpha或beta），保持主版本、次版本和补丁版本不变；对于正式版本，则递增次版本号并重置补丁版本为0。

**Section sources**
- [create-migration.ts](file://packages/core/server/src/commands/create-migration.ts#L32-L39)
- [migration.ts](file://packages/core/database/src/migration.ts#L84-L89)
- [database.ts](file://packages/core/database/src/database.ts#L323-L333)

## 迁移历史记录存储与查询接口

NocoBase使用数据库表存储迁移历史记录，表名为`migrations`（可配置表前缀）。该表在数据库初始化时通过`collection`方法定义，包含`name`作为主键字段，记录每个已执行迁移的名称。

迁移历史的存储由SequelizeStorage适配器管理，该适配器与Sequelize ORM集成，确保迁移状态的原子性更新。`migrator`实例在Database构造函数中初始化，配置了SequelizeStorage作为存储后端，将迁移状态持久化到数据库。

查询接口通过Repository模式提供，允许查询已完成的迁移记录。系统通过`loadMigrations`方法扫描指定目录下的迁移文件，并根据应用当前版本和迁移的`appVersion`条件判断是否需要执行。已完成迁移的验证通过比较文件系统中的迁移文件与数据库中的记录来完成。

**Section sources**
- [database.ts](file://packages/core/database/src/database.ts#L320-L333)
- [application.ts](file://packages/core/server/src/application.ts#L794-L815)
- [migration.ts](file://packages/core/database/src/migration.ts#L59-L65)

## 迁移版本冲突处理策略

在分布式开发环境中，NocoBase通过时间戳前缀的迁移文件命名机制有效避免版本冲突。每个迁移文件以UTC时间戳开头，确保不同开发者创建的迁移脚本具有全局唯一的名称和明确的执行顺序。

系统采用命名空间隔离策略，通过`namespace`参数区分不同插件或模块的迁移脚本。当加载迁移时，系统将命名空间与文件名组合形成完整的迁移名称（格式为`{namespace}/{filename}`），避免不同来源的迁移脚本发生命名冲突。

对于潜在的数据库模式冲突，NocoBase建议在团队协作中采用迁移协调流程：在合并代码前，开发者应同步查看已提交的迁移脚本，避免对同一数据库对象进行并发修改。若发生冲突，可通过手动调整迁移脚本的依赖关系或合并变更来解决。

**Section sources**
- [application.ts](file://packages/core/server/src/application.ts#L811-L812)
- [database.ts](file://packages/core/database/src/database.ts#L507-L508)
- [create-migration.ts](file://packages/core/server/src/commands/create-migration.ts#L29-L30)

## 迁移脚本兼容性管理

NocoBase通过`appVersion`字段实现迁移脚本的向后兼容性保证。该字段使用语义化版本范围语法（如`<0.14.0-alpha.2`），定义迁移脚本适用的应用版本范围。系统在加载迁移时，通过`semver.satisfies`方法检查当前应用版本是否满足迁移的版本条件，从而决定是否执行该迁移。

对于破坏性变更，NocoBase采用渐进式迁移策略。破坏性变更应拆分为多个迁移脚本：首先添加新结构，然后迁移数据，最后移除旧结构。每个步骤独立为一个迁移脚本，确保可以逐步验证和回滚。系统提供`up`和`down`方法支持迁移的正向执行和反向回滚。

迁移规则通过`migrationRules`字段定义，支持`overwrite`和`schema-only`等策略，控制迁移过程中数据的处理方式。例如，`overwrite`规则允许覆盖现有数据，而`schema-only`规则仅更新表结构而不影响数据。

**Section sources**
- [application.ts](file://packages/core/server/src/application.ts#L810-L811)
- [migration.ts](file://packages/core/server/src/migration.ts#L18-L20)
- [sequences.ts](file://packages/plugins/@nocobase/plugin-field-sequence/src/server/collections/sequences.ts#L68-L69)

## 可维护的迁移版本体系设计示例

设计可维护的迁移版本体系应遵循以下最佳实践：首先，为不同环境（开发、测试、生产）使用相同的迁移脚本，确保环境一致性；其次，将迁移脚本按功能模块组织在各自的`migrations`目录中，便于管理和定位；最后，为每个迁移脚本提供清晰的命名和注释，说明其目的和影响范围。

在多环境部署场景下，建议使用CI/CD管道自动化迁移执行。部署流程应包含迁移验证步骤，先检查待执行的迁移列表，再确认数据库备份完成，最后执行迁移。对于关键业务变更，可采用蓝绿部署策略，在新环境中先执行迁移并验证，再切换流量。

长期项目演进中，应定期审查和归档旧的迁移脚本。对于已稳定运行多个版本且不再需要回滚的迁移，可考虑将其合并为一个初始模式迁移脚本，简化迁移历史。但此操作应在所有环境同步完成后进行，并确保有完整的数据库备份。

**Section sources**
- [create-migration.ts](file://packages/core/server/src/commands/create-migration.ts#L40-L51)
- [application.ts](file://packages/core/server/src/application.ts#L821-L848)
- [database.ts](file://packages/core/database/src/database.ts#L350-L369)